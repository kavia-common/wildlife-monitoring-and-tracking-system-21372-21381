from typing import Optional, Dict, Any

import asyncio
from functools import lru_cache

from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase, AsyncIOMotorCollection
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings, SettingsConfigDict


# PUBLIC_INTERFACE
class DatabaseSettings(BaseSettings):
    """
    This settings class holds MongoDB configuration loaded from environment variables.

    Variables:
    - MONGODB_URI: Full MongoDB URI (e.g., mongodb:// or mongodb+srv://)
    - MONGODB_DB_NAME: The logical database name to use for this app
    """
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", extra="ignore")

    MONGODB_URI: str = Field(..., description="MongoDB connection URI")
    MONGODB_DB_NAME: str = Field(..., description="MongoDB database name")


@lru_cache(maxsize=1)
def get_settings() -> DatabaseSettings:
    """Return cached DatabaseSettings instance loaded from environment."""
    return DatabaseSettings()  # type: ignore[arg-type]


_client: Optional[AsyncIOMotorClient] = None
_db: Optional[AsyncIOMotorDatabase] = None


# PUBLIC_INTERFACE
def get_database() -> AsyncIOMotorDatabase:
    """Return the active AsyncIOMotorDatabase. Must be initialized by calling ensure_database()."""
    if _db is None:
        raise RuntimeError("Database not initialized. Call ensure_database() during app startup.")
    return _db


# PUBLIC_INTERFACE
def get_collection(name: str) -> AsyncIOMotorCollection:
    """Get a collection by name from the active database."""
    return get_database()[name]


async def ensure_database() -> AsyncIOMotorDatabase:
    """
    Ensure the global database connection is established. Safe to call multiple times.
    """
    global _client, _db
    if _db is not None:
        return _db

    settings = get_settings()
    _client = AsyncIOMotorClient(settings.MONGODB_URI)
    _db = _client[settings.MONGODB_DB_NAME]

    # a quick ping to validate connectivity
    await _db.command("ping")
    return _db


# PUBLIC_INTERFACE
async def close_database() -> None:
    """Gracefully close MongoDB client."""
    global _client, _db
    if _client is not None:
        _client.close()
    _client = None
    _db = None


# Index definitions and initialization

class IndexSpec(BaseModel):
    """Represents an index to be created on a collection."""
    keys: list[tuple[str, int]]
    name: str
    unique: bool = False
    background: bool = True
    sparse: bool = False


COLLECTIONS: Dict[str, list[IndexSpec]] = {
    # Authentication and users
    "users": [
        IndexSpec(keys=[("email", 1)], name="idx_users_email_unique", unique=True),
        IndexSpec(keys=[("role", 1)], name="idx_users_role"),
    ],
    # Animals being tracked
    "animals": [
        IndexSpec(keys=[("species", 1)], name="idx_animals_species"),
        IndexSpec(keys=[("tag_id", 1)], name="idx_animals_tag_id_unique", unique=True),
    ],
    # Tracking devices assigned to animals
    "devices": [
        IndexSpec(keys=[("device_id", 1)], name="idx_devices_device_id_unique", unique=True),
        IndexSpec(keys=[("animal_id", 1)], name="idx_devices_animal_id"),
        IndexSpec(keys=[("status", 1)], name="idx_devices_status"),
    ],
    # Telemetry data points (location, vitals)
    "telemetry": [
        IndexSpec(keys=[("animal_id", 1), ("timestamp", -1)], name="idx_tel_animal_ts"),
        IndexSpec(keys=[("device_id", 1), ("timestamp", -1)], name="idx_tel_device_ts"),
        IndexSpec(keys=[("location", "2dsphere")], name="idx_tel_location_2dsphere"),
    ],
    # Geofences (polygons/areas)
    "geofences": [
        IndexSpec(keys=[("name", 1)], name="idx_geofences_name_unique", unique=True),
        IndexSpec(keys=[("geometry", "2dsphere")], name="idx_geofences_geometry_2dsphere"),
        IndexSpec(keys=[("active", 1)], name="idx_geofences_active"),
    ],
    # Alerts generated by rules (geofence breaches, inactivity, low battery)
    "alerts": [
        IndexSpec(keys=[("animal_id", 1), ("created_at", -1)], name="idx_alerts_animal_ts"),
        IndexSpec(keys=[("status", 1)], name="idx_alerts_status"),
    ],
    # Crowd/user submitted wildlife sightings
    "sightings": [
        IndexSpec(keys=[("species", 1), ("timestamp", -1)], name="idx_sightings_species_ts"),
        IndexSpec(keys=[("reporter_id", 1), ("timestamp", -1)], name="idx_sightings_reporter_ts"),
        IndexSpec(keys=[("location", "2dsphere")], name="idx_sightings_location_2dsphere"),
    ],
}


async def _create_indexes_for_collection(name: str, specs: list[IndexSpec]) -> None:
    """
    Create indexes for a single collection based on specifications.
    Supports both standard and geospatial (2dsphere) indexes.
    """
    coll = get_collection(name)
    to_create: list[tuple[list[tuple[str, Any]], Dict[str, Any]]] = []
    for spec in specs:
        # Convert ("field", "2dsphere") to appropriate Motor spec
        keys: list[tuple[str, Any]] = []
        for field, order in spec.keys:
            if isinstance(order, str) and order.lower() == "2dsphere":
                keys.append((field, "2dsphere"))
            else:
                keys.append((field, order))
        options: Dict[str, Any] = {
            "name": spec.name,
            "unique": spec.unique,
            "background": spec.background,
            "sparse": spec.sparse,
        }
        to_create.append((keys, options))

    # Create indexes concurrently
    await asyncio.gather(*[
        coll.create_index(keys, **options)  # type: ignore[arg-type]
        for keys, options in to_create
    ])


# PUBLIC_INTERFACE
async def init_indexes() -> None:
    """
    Initialize database (connect if needed) and ensure all required indexes exist.
    Should be called on application startup.
    """
    await ensure_database()
    # Create collections implicitly by creating indexes
    await asyncio.gather(*[
        _create_indexes_for_collection(name, specs)
        for name, specs in COLLECTIONS.items()
    ])
